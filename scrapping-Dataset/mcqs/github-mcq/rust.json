[
    {
        "question": "Which type cast preserves the mathematical value in all cases?",
        "options": [
            "i64 as i32",
            "usize as u64",
            "i32 as i64",
            "f64 as f32"
        ],
        "answer": "i32 as i64"
    },
    {
        "question": "What do the vertical bars represent here?",
        "options": [
            "a closure",
            "a thread",
            "a future",
            "a block"
        ],
        "answer": "a closure"
    },
    {
        "question": "Which choice is not a scalar data type?",
        "options": [
            "integer",
            "float",
            "boolean",
            "tuple"
        ],
        "answer": "tuple"
    },
    {
        "question": "**\\_** cannot be destructured.",
        "options": [
            "Traits",
            "Tuples",
            "Enums",
            "Structs"
        ],
        "answer": "Traits"
    },
    {
        "question": "Which `cargo` command checks a program for error without creating a binary executable?",
        "options": [
            "cargo --version",
            "cargo init",
            "cargo build",
            "cargo check"
        ],
        "answer": "cargo check"
    },
    {
        "question": "The term _box_ and related phrases such as _boxing a value_ are often used when relating to memory layout. What does _box_ refer to?",
        "options": [
            "It's creating a pointer on the heap that points to a value on the stack.",
            "It's creating a pointer on the stack that points to a value on the heap.",
            "It's creating a memory guard around values to prevent illegal access.",
            "It's an abstraction that refers to ownership. \"Boxed\" values are clearly labelled."
        ],
        "answer": "It's creating a pointer on the stack that points to a value on the heap."
    },
    {
        "question": "What is an alternative way of writing `slice` that produces the same result?",
        "options": [
            "let slice = &s[len + 2];",
            "let slice = &s[len - 2];",
            "let slice = &s.copy(0..2);",
            "let slice = &s[..2];"
        ],
        "answer": "let slice = &s[..2];"
    },
    {
        "question": "Using the `?` operator at the end of an expression is equivalent to **\\_**.",
        "options": [
            "a match pattern that branches into True or False",
            "calling ok_error()",
            "calling panic!()",
            "a match pattern that may result an early return"
        ],
        "answer": "a match pattern that may result an early return"
    },
    {
        "question": "Which is valid syntax for defining an array of i32 values?",
        "options": [
            "Array<i32>::with_capacity(10)",
            "[i32]",
            "Array<i32>::new(10)",
            "[i32; 10]"
        ],
        "answer": "[i32; 10]"
    },
    {
        "question": "What syntax is required to take a mutable reference to T, when used within a function argument?",
        "options": [
            "\\*mut T",
            "mut ref T",
            "mut &T",
            "&mut T"
        ],
        "answer": "&mut T"
    },
    {
        "question": "The smart pointers Rc and Arc provide reference counting. What is the API for incrementing a reference count?",
        "options": [
            ".add()",
            ".incr()",
            ".clone()",
            ".increment()"
        ],
        "answer": ".clone()"
    },
    {
        "question": "What happens when an error occurs that is being handled by the question mark (?) operator?",
        "options": [
            "The error is reported and execution continues.",
            "An exception is raised. The effect(s) of the exception are defined by the error! macro.",
            "The program panics immediately.",
            "Rust attempts to convert the error to the local function's error type and return it as Result::Err. If that fails, the program panics."
        ],
        "answer": "Rust attempts to convert the error to the local function's error type and return it as Result::Err. If that fails, the program panics."
    },
    {
        "question": "Which comment syntax is not legal?",
        "options": [
            "`/*`",
            "`#`",
            "`//!`",
            "`//`"
        ],
        "answer": "`#`"
    },
    {
        "question": "In matching patterns, values are ignored with \\_.",
        "options": [
            "`.ignore()`",
            "`an underscore (_)`",
            "..",
            "skip"
        ],
        "answer": ".."
    },
    {
        "question": "Defining a \\_ requires a lifetime parameter.",
        "options": [
            "function that ends the lifetime of one of its arguments",
            "struct that contains a reference to a value",
            "function with a generic argument",
            "struct that contains a reference to a boxed value"
        ],
        "answer": "struct that contains a reference to a value"
    },
    {
        "question": "Which example correctly uses std::collections::HashMap's Entry API to populate counts?",
        "options": [
            "&shy;",
            "&shy;",
            "&shy;",
            "&shy;"
        ],
        "answer": "&shy;"
    },
    {
        "question": "Which fragment does not incur memory allocations while writing to a \"file\" (represented by a Vec<u8>)?",
        "options": [
            ":",
            ":",
            ":",
            ":"
        ],
        "answer": ":"
    },
    {
        "question": "Does the `main` function compile? If so, why? If not, what do you need to change?",
        "options": [
            "The code does not compile. `let` statements require a refutable pattern. Add `if` before `let`.",
            "The code compiles. `let` statements sometimes require a refutable pattern.",
            "The code does not compile. `let` statements requires an irrefutable pattern. Add `if` before `let`.",
            "The code compiles. `let` do not require a refutable pattern."
        ],
        "answer": "The code does not compile. `let` statements requires an irrefutable pattern. Add `if` before `let`."
    },
    {
        "question": "Which statement about lifetimes is false?",
        "options": [
            "Lifetimes were redundantly specified in previous version of Rust.",
            "Lifetimes are specified when a struct is holding a reference to a value.",
            "Lifetimes are specified when certain values must outlive others.",
            "Lifetimes are always inferred by the compiler."
        ],
        "answer": "Lifetimes are always inferred by the compiler."
    },
    {
        "question": "When used as a return type, which Rust type plays a similar role to Python's `None`, JavaScript's `null`, or the `void` type in C/C++?",
        "options": [
            "`!`",
            "`None`",
            "`Null`",
            "`()`"
        ],
        "answer": "`()`"
    },
    {
        "question": "To convert a `Result` to an `Option`, which method should you use?",
        "options": [
            "`.as_option()`",
            "`.ok()`",
            "`.to_option()`",
            "`.into()`"
        ],
        "answer": "`.ok()`"
    },
    {
        "question": "Which statement about the `Clone` and `Copy` traits is false?",
        "options": [
            "`Copy` is enabled for primitive, built-in types.",
            "Without `Copy`, Rust applies move semantics to a type's access.",
            "When using `Clone`, copying data is explicit.",
            "Until a type implements either `Copy` or `Clone`, its internal data cannot be copied."
        ],
        "answer": "`Copy` is enabled for primitive, built-in types."
    },
    {
        "question": "Why does this code _not_ compile?",
        "options": [
            "The returned `fn` pointer and value need to be represented by another trait.",
            "Closures are types, so they cannot be returned directly from a function.",
            "Closures are types and can be returned only if the concrete trait is implemented.",
            "Closures are represented by traits, so they cannot be a return type."
        ],
        "answer": "Closures are represented by traits, so they cannot be a return type."
    },
    {
        "question": "What smart pointer is used to allow multiple ownership of a value in various threads?",
        "options": [
            "`Arc<T>`",
            "`Box<T>`",
            "Both `Arc<T>` and `Rc<T>` are multithread safe.",
            "`Rc<T>`"
        ],
        "answer": "`Arc<T>`"
    },
    {
        "question": "Which types are _not_ allowed within an enum variant's body?",
        "options": [
            "zero-sized types",
            "structs",
            "trait objects",
            "floating-point numbers"
        ],
        "answer": "trait objects"
    },
    {
        "question": "Which statement about this code is true?",
        "options": [
            "Both are character literals.",
            "`heart_eyed_cat` is an invalid expression.",
            "`c` is a string literal and `heart_eyed_cat` is a character literal.",
            "Both are string literals."
        ],
        "answer": "Both are character literals."
    },
    {
        "question": "Your application requires a single copy of some data type T to be held in memory that can be accessed by multiple threads. What is the thread-safe wrapper type?",
        "options": [
            "`Mutex<Arc<T>>`",
            "`Rc<Mutex<T>>`",
            "`Arc<Mutex<T>>`",
            "`Mutex<Rc<T>>`"
        ],
        "answer": "`Arc<Mutex<T>>`"
    },
    {
        "question": "Which idiom can be used to concatenate the strings `a`, `b`, `c`?",
        "options": [
            "`String::from(a,b,c)`",
            "`format!(\"{}{}{}\", a, b, c)`",
            "`concat(a,b,c)`",
            "`a + b + c`"
        ],
        "answer": "`format!(\"{}{}{}\", a, b, c)`"
    },
    {
        "question": "In this function. what level of access is provided to the variable `a`?",
        "options": [
            "print",
            "read-only",
            "read/write",
            "debug"
        ],
        "answer": "read-only"
    },
    {
        "question": "Which choice is _not_ valid loop syntax?",
        "options": [
            "`loop`",
            "`for`",
            "`while`",
            "`do`"
        ],
        "answer": "`do`"
    },
    {
        "question": "How do you construct a value of `Status` that is initialized to `Waiting`?",
        "options": [
            "`let s = Enum::new(Status::Waiting);`",
            "`let s = new Status::Waiting;`",
            "`let s = Status::Waiting;`",
            "`let s = Status::new(Waiting);`"
        ],
        "answer": "`let s = Status::Waiting;`"
    },
    {
        "question": "Which statement about enums is false?",
        "options": [
            "Enums are useful in matching patterns.",
            "Option is an enum type.",
            "Enum variants can have different types with associated data.",
            "the term _enum_ is short for _enummap_"
        ],
        "answer": "the term _enum_ is short for _enummap_"
    },
    {
        "question": "What does an underscore (\\_) indicate when used as pattern?",
        "options": [
            "It matches everything.",
            "It matches underscores.",
            "It matches any value that has a length of 1.",
            "It matches nothing."
        ],
        "answer": "It matches everything."
    },
    {
        "question": "What is a safe operation on a `std::cell:UnsafeCell<T>`?",
        "options": [
            "A `&mut T` reference is allowed. However it may not cpexists with any other references. and may be created only in single-threaded code.",
            "`UnsafeCell<T>` provides thread-safety. Therefore, creating `&T` references from multiple threads is safe.",
            "The only safe operation is the `.get()` method, which returns only a raw pointer.",
            "Non. `UnsafeCell<T>` only allows code that would otherwise need unsafe blocks to be written in safe code."
        ],
        "answer": "The only safe operation is the `.get()` method, which returns only a raw pointer."
    },
    {
        "question": "Generics are useful when you **\\_**.",
        "options": [
            "need to reduce code duplication by concretizing values and restricting parameters in functions",
            "need to reduce code duplication by abstracting values further, such as in function parameters",
            "need a supertrait",
            "are not sure if you need a specific kind of trait"
        ],
        "answer": "need to reduce code duplication by abstracting values further, such as in function parameters"
    },
    {
        "question": "How do you create a Rust project on the command-line?",
        "options": [
            "cargo new",
            "rustup init",
            "cargo start",
            "rust new-project"
        ],
        "answer": "cargo new"
    },
    {
        "question": "Calling.clone() **\\_**.",
        "options": [
            "deeply copies heap data and clones ownership",
            "clones the pointer to the heap",
            "clones the heap data onto the stack",
            "deeply copies heap and stack"
        ],
        "answer": "clones the pointer to the heap"
    },
    {
        "question": "what is one of the roles of the let keyword?",
        "options": [
            "Create a text object.",
            "Assign a mutable value.",
            "request to borrow a string.",
            "Assign an immutable value."
        ],
        "answer": "request to borrow a string."
    },
    {
        "question": "How is a new enum initialized?",
        "options": [
            "let integer = Option_i32::Some(5);",
            "let integer = Option_i32.new(Some(5))",
            "let integer = Option_i32::New::(Some(5))",
            "let integer = Option_i32.init()"
        ],
        "answer": "let integer = Option_i32::Some(5);"
    },
    {
        "question": "What are the main difference between const and static?",
        "options": [
            "They can be used interchangeably, but const only supports primitive types while static must be used for structs and user-defined types.",
            "They can be used interchangeably, but const values are compiled at compile time.",
            "Values defined with const live in the stack, while static values live on the heap.",
            "Values defined with const can be copied to wherever they are needed, whereas static values remain in a fixed place in memory."
        ],
        "answer": "Values defined with const can be copied to wherever they are needed, whereas static values remain in a fixed place in memory."
    },
    {
        "question": "Which Rust data type represents a signed integer that has the same width as a pointer of the compile target's CPU?",
        "options": [
            "i64",
            "int64",
            "isize",
            "int"
        ],
        "answer": "isize"
    },
    {
        "question": "When are supertraits needed?",
        "options": [
            "when a trait is needed for multiple structs",
            "when a trait depends on another trait",
            "only when a generic trait is used",
            "when a metatrait is needed to use another trait"
        ],
        "answer": "when a trait depends on another trait"
    },
    {
        "question": "Which types are legal for x to be in this snippet?",
        "options": [
            "every type that implements the std::cmp::Truth trait",
            "only the primitive bool type",
            "both bool and u8 (which is how bool is implemented under the hood)",
            "bool and std::sync::atomic::AtomicBool"
        ],
        "answer": "only the primitive bool type"
    },
    {
        "question": "How do you access the married data in this struct?",
        "options": [
            "person.getMarried()",
            "person[married]",
            "person.value(married)",
            "person.married"
        ],
        "answer": "person.married"
    },
    {
        "question": "To mark a function as visible to other crates, what do you need to do to its definition?",
        "options": [
            "Add the public keyword.",
            "Add the pub keywork.",
            "Begin the function's name with a capital letter.",
            "Remove the private keyword."
        ],
        "answer": "Add the pub keywork."
    },
    {
        "question": "Which choice is a compound data type?",
        "options": [
            "char",
            "tuple",
            "bool",
            "i32"
        ],
        "answer": "tuple"
    },
    {
        "question": "How could you make this function compile?",
        "options": [
            "Use x only once in a println!() statement.",
            "Place curly brackets around let x = 5.",
            "Add const to let x = 6.",
            "Add mut to let x = 5."
        ],
        "answer": "Add mut to let x = 5."
    },
    {
        "question": "Using .unwrap() will \\_.",
        "options": [
            "let you choose the expected panic error message",
            "call panic! if there is an error or absence of value",
            "unwrap the value inside an unsafe wrapper",
            "return the error inside Ok()"
        ],
        "answer": "call panic! if there is an error or absence of value"
    },
    {
        "question": "When should the panic! macro be called instead of using std::result::Result?",
        "options": [
            "when there is a way to encode the information in types used",
            "when your code is expected to end in a good state",
            "when the situation is considered unrecoverable",
            "when valid values are passed on the code"
        ],
        "answer": "when the situation is considered unrecoverable"
    },
    {
        "question": "Which statement about arrays is true?",
        "options": [
            "[<T>; size of array] can initialize arrays.",
            "Indexing, such as array.0, accesses elements in arrays.",
            "A data structure for collections can contain different types of values.",
            "Arrays are useful when you want to allocate data on the heap and then on the stack."
        ],
        "answer": "[<T>; size of array] can initialize arrays."
    },
    {
        "question": "How would you select the value 2.0 from this tuple?",
        "options": [
            "pt[1]",
            "pt(1)",
            "pt.iter().nth(1)",
            "pt.1"
        ],
        "answer": "pt.1"
    },
    {
        "question": "When writing tests, which macro should you use to assert equality between two values?",
        "options": [
            "assert_eq!()",
            "assert_equal!()",
            "is_equals!()",
            "assert!()"
        ],
        "answer": "assert_eq!()"
    },
    {
        "question": "Which code statement in Rust is used to define a BTreeMap object?",
        "options": [
            "let btm=BTreeMap::new()",
            "let mut btm=BTreeMap::new()",
            "BTreeMap btm = BTreeMap.new()",
            "BTreeMap btm = std::collections::BTreeMap::new()"
        ],
        "answer": "let mut btm=BTreeMap::new()"
    },
    {
        "question": "#### Q54 .Rust is known to be memory safe. Which feature is the main reason for the memory safety of Rust?",
        "options": [
            "ownership",
            "borrowing",
            "lifetimes",
            "reference"
        ],
        "answer": "ownership"
    },
    {
        "question": "#### Q55 . To support Dynamic Sized variables, what should we use in place of \"f32\"?",
        "options": [
            "Not supportedin Rust",
            "use array",
            "?sized",
            "list all data-types"
        ],
        "answer": "?sized"
    },
    {
        "question": "#### Q56 . What is \"Drop\" in Rust used for?",
        "options": [
            "run code as multi-threaded",
            "run code when variable is out of scope",
            "run code and drop it if error comes",
            "option 4"
        ],
        "answer": "run code when variable is out of scope"
    },
    {
        "question": "#### Q57 . In Rust, how is a macro from the above Rust code snippet used?",
        "options": [
            "foo(x)",
            "#foo",
            "foo!()",
            "foo"
        ],
        "answer": "foo!()"
    },
    {
        "question": "#### Q58 . Which library does Rust use for memory allocation?",
        "options": [
            "tcmalloc",
            "mimalloc",
            "ptmalloc",
            "jemalloc"
        ],
        "answer": "jemalloc"
    },
    {
        "question": "#### Q59 . Who designed Rust from scratch in 2006?",
        "options": [
            "Graydon Hoare",
            "Yukihiro Matsumoto",
            "Guido Van Rossum",
            "David flanagan"
        ],
        "answer": "Graydon Hoare"
    },
    {
        "question": "Which types are _not_ allowed within an enum variant's body?",
        "options": [
            "zero-sized types",
            "structs",
            "trait objects",
            "floating-point numbers"
        ],
        "answer": "trait objects"
    },
    {
        "question": "Which example correctly uses std::collections::HashMap's Entry API to populate counts?",
        "options": [
            "&shy;",
            "&shy;",
            "&shy;",
            "&shy;"
        ],
        "answer": "&shy;"
    },
    {
        "question": "To convert a `Result` to an `Option`, which method should you use?",
        "options": [
            "`.as_option()`",
            "`.ok()`",
            "`.to_option()`",
            "`.into()`"
        ],
        "answer": "`.ok()`"
    },
    {
        "question": "Which statement about this code is true?",
        "options": [
            "Both are character literals.",
            "`heart_eyed_cat` is an invalid expression.",
            "`c` is a string literal and `heart_eyed_cat` is a character literal.",
            "Both are string literals."
        ],
        "answer": "Both are character literals."
    },
    {
        "question": "What is an alternative way of writing `slice` that produces the same result?",
        "options": [
            "let slice = &s[len + 2];",
            "let slice = &s[len - 2];",
            "let slice = &s.copy(0..2);",
            "let slice = &s[..2];"
        ],
        "answer": "let slice = &s[..2];"
    },
    {
        "question": "How would you select the value 2.0 from this tuple?",
        "options": [
            "pt[1]",
            "pt(1)",
            "pt.iter().nth(1)",
            "pt.1"
        ],
        "answer": "pt.1"
    },
    {
        "question": "What is the purpose of the move keyword in Rust?",
        "options": [
            "To indicate that a value should be moved instead of copied.",
            "To indicate that a value should be copied instead of moved.",
            "To indicate that a value should be borrowed instead of owned.",
            "To indicate that a value should be owned instead of borrowed."
        ],
        "answer": "To indicate that a value should be moved instead of copied.",
        "explanation": null,
        "codeblock": null
    }
]