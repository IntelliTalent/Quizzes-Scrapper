[
    {
        "question": "Aggregation pipeline was introduced in MongoDB version ______",
        "options": [
            "a) 2.1",
            "b) 2.2",
            "c) 2.4",
            "d) 3.0"
        ],
        "answer": "b",
        "explanation": "The aggregation pipeline provides an alternative to map-reduce."
    },
    {
        "question": "Point out the wrong statement.",
        "options": [
            "a) Aggregation pipeline have some limitations on value types and result size",
            "b) The aggregation pipeline is a framework for data aggregation modeled on the concept of data processing pipelines",
            "c) Documents enter a multi-stage pipeline that transforms the documents into an aggregated results",
            "d) All of the mentioned"
        ],
        "answer": "d",
        "explanation": "The MongoDB aggregation pipeline consists of stages."
    },
    {
        "question": "________ calculates aggregate values for the data in a collection.",
        "options": [
            "a) db.collection.aggregate",
            "b) db.collection.agg",
            "c) db.collection.pipeline",
            "d) all of the mentioned"
        ],
        "answer": "a",
        "explanation": "In the mongo shell, if the cursor returned from the db.collection.aggregate() is not assigned to a variable using the var keyword, then the mongo shell automatically iterates the cursor up to 20 times."
    },
    {
        "question": "Cursors returned from aggregation only supports cursor methods like ________________",
        "options": [
            "a) cursor.hasNext()",
            "b) cursor.Next()",
            "c) cursor.has()",
            "d) all of the mentioned"
        ],
        "answer": "a",
        "explanation": " cursor.hasNext() returns true if the cursor returned by the db.collection.find() query can iterate further to return more documents."
    },
    {
        "question": "Point out the wrong statement.",
        "options": [
            "a) Some pipeline stages may generate new documents or filter out documents",
            "b) Pipeline stages do need to produce one output document for every input document",
            "c) Pipeline stages can appear multiple times in the pipeline",
            "d) None of the mentioned"
        ],
        "answer": "b",
        "explanation": "Pipeline stages do need to produce one output document for every input document."
    },
    {
        "question": "______ can be used to iterate the cursor of document results returned by db.collection.find().",
        "options": [
            "a) it",
            "b) next",
            "c) cur",
            "d) none of the mentioned"
        ],
        "answer": "a",
        "explanation": "The mongo shell iterates the returned cursor automatically to print the results."
    },
    {
        "question": "To handle large datasets, set _________ option to true to enable writing data to temporary files.",
        "options": [
            "a) enableDiskUse",
            "b) allowDiskUse",
            "c) validateDiksUse",
            "d) none of the mentioned"
        ],
        "answer": "b",
        "explanation": "In the mongo shell, when you assign the cursor returned from the find() method to a variable using the var keyword, the cursor does not automatically iterate."
    },
    {
        "question": "Syntax for specifying an initial batch size for the cursor is ________________",
        "options": [
            "a) cursor: { batchSize: <string> }",
            "b) cursor: { batchSize: <int> }",
            "c) cur: { batchSize: <int> }",
            "d) none of the mentioned"
        ],
        "answer": "b",
        "explanation": "A batchSize of 0 means an empty first batch and is useful for quickly returning a cursor or failure message without doing significant server-side work."
    },
    {
        "question": "Query shape consists of a combination of query, sort, and _________ specifications.",
        "options": [
            "a) selection",
            "b) projection",
            "c) collection",
            "d) none of the mentioned"
        ],
        "answer": "c",
        "explanation": "If an index filter exists for a given query shape, the optimizer only considers those indexes specified in the filter."
    },
    {
        "question": "Which of the following method is overrided by Index filters?",
        "options": [
            "a) hint",
            "b) plan",
            "c) execute",
            "d) all of the mentioned"
        ],
        "answer": "a",
        "explanation": "When an index filter exists for the query shape, MongoDB ignores the hint()."
    }
]